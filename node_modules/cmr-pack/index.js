const fs = require('fs');
const path = require('path');
const http = require("http");
const events = require('events');
const parser = require('@babel/parser');
const {transformFromAst} = require("@babel/core");
const traverse = require('@babel/traverse').default;
const t = require('@babel/types');
const md5 = require("md5");
const postcss = require('postcss');
const postcssScss = require("postcss-scss");
const postcssLess = require("postcss-less");
const eventEmitter = new events.EventEmitter();
const lessLoader = require("./lib/less-loader/dist/cjs");

// route 404
eventEmitter.on('404', function(method, url, response){
    response.writeHead(404, {'Content-Type': 'text/plain'});
    response.end('404 Not Found\n');
});


const Parser = {
    getAst: (path, rules) => {
        let content = fs.readFileSync(path, 'utf-8');
        const option = {
            rules
        }
        Object.keys(rules).forEach((item) => {
            // const reg = new RegExp(`/\${item}$/`, `g`);

            if (path.search(item) !== -1) {
                const dn = require(rules[item]);
                content = dn.call(option, content);
            }
            else {
                content = fs.readFileSync(path, 'utf-8')
            }
        });

        const source = parser.parse(content, {
            sourceType: 'module',
            plugins: ["jsx"]
        });

        return source;
    },

    getDeclaration: (ast, filename) => {
        const dependecies = {};

        traverse(ast, {
            CallExpression (p) {
                // console.log(p);
            },

            // 类型为 ImportDeclaration 的AST 节点 为 import 语句
            ImportDeclaration({node}) {
                const dirname = path.dirname(filename);

                const filepath = './' + path.join(dirname, node.source.value);
                dependecies[node.source.value] = node.source.value;
            },

            // 字符串字面量
            StringLiteral({node}) {
                // node.value = '12312312';
            },

            ExpressionStatement: testFn
        });
        return dependecies;
    },

    getCode: (ast) => {
        const {code} = transformFromAst(ast, null, {
            presets: ['@babel/preset-env'],
            plugins: ['@babel/plugin-transform-react-jsx']
        });
        return code;
    },

    traverseCssContent: function (filename, callback) {
        let content = fs.readFileSync(filename, { encoding: 'utf-8' });
        let type = filename.split('.').pop();
        let ast = null;
        switch (type) {
            case "css": {
                ast = postcss.parse(content);
                // css 引入
                ast.walkAtRules('import', rule => {
                    let target = rule.params.replace(/['"]/g, '');
                    !target.startsWith('./') && (target = './' + target);
                    Parser.traverseCssContent(target, callback);
                })
                // 图片地址
                ast.walkDecls(decl => {
                    if (decl.value.includes('url(')) {
                        const url = /.*url\((.+)\).*/.exec(decl.value)[1].replace(/['"]/g, '');

                    }
                });

                let newCss = ''
                postcss.stringify(ast, function(textCss, data ) {
                    if (data && data.type !== 'atrule') {
                        newCss += textCss;
                    }
                })
                callback(newCss);
                break;
            }
            case "sass": {
                ast = postcssScss.parse(content);
                break;
            }
            case "less": {
                const _this = {
                    async: function () {
                        return (data) => {
                            const {css} = data;
                            callback(css);
                        }
                    }
                };
                lessLoader.call(_this, content);
                break;
            }
        }
    }
};


function testFn (path) {
    const {node} = path;
    // 测试 将 jj() -> console.log
    // if (node.expression.callee.name === 'jj') {
    //     path.replaceWith(
    //         t.callExpression(
    //             t.memberExpression(t.identifier('console'), t.identifier('log')),
    //             path.node.expression.arguments
    //         )
    //     );
    // }
}


class Compiler {
    constructor(option) {
        const { entry, output, module, port } = option;

        this.entry = entry;

        this.output = output;

        this.rules = module.rules.reduce((rulesObj, item) => {
            rulesObj[item.test] = item.loader;
            return rulesObj;
        }, {});

        this.modules = [];


        this.port = port || 8080;
    }

    run (type = 'start') {
        console.log(`生成 ${this.output.path} 打包目录中.......`);
        fs.mkdir(this.output.path, (err) => {
            if (err) {
                console.log(`生成 ${this.output.path} 打包目录 存在`);
            }
            console.log(`生成 ${this.output.path} 打包目录 成功`);
            this.cssPath = path.join(this.output.path, 'index.css');
            this.htmlPath = path.join(this.output.path, 'index.html');

            console.log(`样式 ${this.cssPath} 生成中......`);
            fs.writeFileSync(this.cssPath, '', 'utf-8');

            const html = fs.readFileSync(path.resolve(__dirname, '../../index.html'), { encoding: 'utf-8' });
            fs.writeFileSync(this.htmlPath, html.replace('</head>', `    <link rel="stylesheet" href="./index.css">
    <script src="./${this.output.filename}" async></script>
</head>`), 'utf-8');

            const info = this.build(this.entry);
            this.modules.push(info);

            // 生成依赖关系
            const dependencyGraph = this.modules.reduce((graph, item) => {
                return {
                    ...graph,
                    [item.filename]: {
                        dependecies: item.dependecies,
                        code: item.code
                    }
                };
            }, {});

            this.generate(dependencyGraph, type);
        });
    }

    build (filename) {
        const {getAst, getCode, getDeclaration, getRulesAst, traverseCssContent} = Parser;

        const ast = getAst(filename, this.rules);
        const dependecies = getDeclaration(ast, filename);
        const code = getCode(ast);
        // 递归依赖
        if (Object.keys(dependecies).length) {
            for (const dependency in dependecies) {

                const pathName = dependecies[dependency];

                if (['.css', '.scss', '.less'].find(res => pathName.indexOf(res) > -1)) {

                    traverseCssContent(pathName, (content) => {
                        const filePath = path.join(this.output.path, 'index.css');
                        fs.appendFile(filePath, content, (err) => {
                            if (err) {
                                console.log(`样式 ${this.cssPath} 生成失败`);
                            }
                            else {
                                console.log(`样式 ${this.cssPath} 生成成功`);
                            }
                        });
                    });
                }
                else {
                    this.modules.push(this.build(pathName));
                }
            }
        }

        return {
            filename,
            dependecies,
            code
        };
    }

    // 重写require 函数, 输出 bundle
    generate (code, type) {

        const filePath = path.join(this.output.path, this.output.filename);

        const bundle = `(function (graph) {
            function require (module) {
                function localRequire (relativePath) {
                    return require(graph[module].dependecies[relativePath])
                }
            
                const exports = {};
                
                (function (require, exports, code) {
                    eval(code);
                })(localRequire, exports, graph[module] && graph[module].code);
                
                return exports;
            }

            require('${this.entry}');
        })(${JSON.stringify(code)})`;

        fs.writeFileSync(filePath, bundle, 'utf-8');
        console.log(`${filePath} JS文件生成成功`);
        console.log(`服务启动成功 http://localhost:${this.port}/index.html`);
        if (type === 'change') return;
        // node 服务
        if (this.port) {
            handOut(this.output.path);
            // 启动服务
            http.createServer(function (request, response) {
                // 分发
                if (eventEmitter.listenerCount(request.url) > 0){
                    eventEmitter.emit(request.url, request.method, response);
                }
                else {
                    eventEmitter.emit('404', request.method, request.url, response);
                }
            }).listen(this.port);
        }
    }
};

// 分发资源
function handOut (path) {
    // 读取打包文件夹
    fs.readdir(path, function (err, files) {
        // 遍历内部文件
        files.forEach((item) => {
            // 监听相应路由读取相应文件
            eventEmitter.on('/' + item, function(method, response) {
                const filepath = path + '/' + item;
                fs.readFile(filepath, (err, data) => {
                    switch (item.split(1)) {
                        case 'js': {
                            response.writeHead(200, {'Content-Type': 'application/x-javascript;charset=utf8'});
                            break;
                        }
                        case 'html': {
                            response.writeHead(200, {'Content-Type': 'text/html;charset=utf8'});
                            break;
                        }
                    }
                    response.end(data);
                });
            });
        });
    });
}

exports.run = function(option) {
    const myPack = new Compiler(option);
    myPack.run();

    let md5Previous = null;
    let fsWait = false;
    const dir = path.resolve(__dirname, '../..');
    fs.watch(dir, (event, filename) => {
        if (filename) {
            if (fsWait) return;
            fsWait = setTimeout(() => {
                fsWait = false;
            }, 100);
            // const md5Current = md5(fs.readFileSync(dir));
            // if (md5Current === md5Previous) {
            //     return;
            // }
            // md5Previous = md5Current;
            console.log(`${filename} file Changed`);
            myPack.run('change');
        }
    });
}
